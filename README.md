# Frontend quick guide

В дефолтной сборке используются сборщик Gulp, препроцессор LESS. 

HTML код пишется в PHP файлах. При этом PHP знать почти не обязательно - можно писать обычный HTML, - а при некотором знании можно даже использовать PHP в качестве шаблонизатора.

## Разворачивание проекта

- Скачиваем репозиторий [libs](http://hg.turbodevelopers.com/turbo/libs)
- Переходим в крайнюю ревизию ветки `altVersion-ks`
- Создаем папку для нового проекта, копируем туда все содержимое из `libs`
- В терминале переходим в папку `имя_проекта\templates` и запускаем `npm install` для установки npm модулей

## Типовая структура проекта

Прежде, чем говорить о верстке, необходимо описать типовую струткуру проекта.

```
templates                           # Весь фронтенд проекта
    ├── build/                      # Итоговые файлы для разработки и продакшена. Здесь не нужно ничего трогать, т.к. все файлы пересобираются сборщиком автоматически.
        ├── css/                    # Итоговые css файлы (dev и min версии)
        ├── js/                     # Итоговые js файлы (dev и min версии)
        └── images/                 # Сжатые картинки и итоговые спрайты (копируются из папки templates/images/)
    ├── components/                 # PHP компоненты проекта
    ├── fonts/                      # Шрифты, если шрифтов несколько, то лучше разложить их по папкам
    ├── gulp/                       # Вспомогательные Gulp таски, сюда лезть скорее всего не придется, т.к. из коробки все что нужно уже настроено
        ├── core/                   # Обертка для Gulp, добавляющая некоторые возможности и упрощающая разработку
	├── modules/                # Таски для PNG и SVG спрайтов
	└── utils/                  # Gulp утилиты
    ├── images/                     # Картинки для dev сборки, лучше раскладывать их по папкам
        ├── png-sprites/            # PNG спрайты
	├── sprite.svg              # SVG спрайт для подключения в LESS
	└── symbols.svg             # SVG спрайт для подключения в HTML
    ├── pages/                      # PHP страницы проекта
    ├── sprites/                    # Исходники для спрайтов
        ├── png/                    # Картинки для PNG спрайтов
        └── svg/                    # Картинки для SVG спрайтов
    ├── src/                        # Исходный код проекта
        ├── js/                     # Скрипты
            ├── BView/              # Backbone Views ("вьюхи")
                └── subView/        # "Сабвьюхи" - модули, которые могут использоваться в нескольких вьюхах
            ├── components/         # Компоненты
            ├── core/               # Базовые скрипты
            ├── libs/               # Сторонние библиотеки
            └── script.js           # Точка входа для скриптов (инициализация приложения)
        ├── less/                   # Стили
            ├── core/               # Базовые стили (normalize, шрифты, спрайты и т.п.)
            ├── common/             # Базовые модули (header, footer и т.п.)
            ├── modules/            # Все остальные модули
            ├── libs/               # Стили библиотек и плагинов
            └── styles.less         # Точка входа для стилей        
    ├── BODY.tpl.php                # Точка входа для PHP страниц
    └── gulpfile.js                 # Основные Gulp таски для сборки проекта
```

## HTML верстка

Как уже было сказано, вся верстка делается в PHP файлах, при этом PHP знать почти не обязательно - пишите обычный HTML.

Для верстки предусмотрены 2 папки: `components` и `pages`.

В `components` кладутся куски кода, которые встречаются более, чем на одной странице (хедер, футер и т.п.). Таким образом, мы пишем код всего один раз и подключаем его где хотим через директиву `include` или функцию `component()` (которая делает тот же самый `include`, но чуть удобней).

```php
<? 
// Подключение компонента
component('head'); 
?>
```

В `pages` кладутся непосредственно страницы сайта (index, news, contatcs и т.п.). Под страницей подразумевается кусок сайта между хедером и футером. Страницы могут включать в себя как компоненты, так и уникальный код.

Пример главной траницы:
```php
<?
define('PAGE_TITLE','Главная');
define('PAGE_SECTION_ID','0');
define('PAGE_JS_VIEW','Index');
?>

<div class="home" data-view="<?=PAGE_JS_VIEW?>"> ... </div>
```

Кроме этого, в папке templates лежит файл `BODY.tpl.php` - в нем подключаются хедер, футер и ряд других компонентов, а также находится точка входа для всех страниц сайта (переменная `<?=$CONTENT?>`). 

Таким образом, чтобы создать страницу новостей, нужно в папке `pages` создать файл `news.php`. Он автоматически подхватится точкой входа и станет доступен по адресу `имя_проекта/news`.

## Стили

Стили нужно писать модульно. Один файл должен содержать ровно ОДИН модуль (например, в `header.less` должны быть стили только для хедера). Название файла и класса по возможности должны совпадать.

Все файлы подключаются через директиву `@import` в одной точке входа - `styles.less`. Соответственно при добавлении нового файла со стилями его нужно не забыть подключить в `styles.less`.

```less
@import "modules/news";
```

В папке `core` содержаться базовые стили, которые со временем не будут меняться, либо будут меняться крайне редко. Сюда относятся: переменные, миксины, normalize/reset, подключение шрифтов, спрайтов и т.п..

В папку `libs` складываются стили библиотек и плагинов. Можно кидать сюда `css` и подключать в точке входа через `@import` с флагом `(less)`.

```less
@import (less) "libs/swiper.css";
```

В папке `common` складываются базовые стили (для тегов, врапперов, сеток и т.п.) и базовые модули проекта (header, footer).

Стили всех остальных модулей складываются в папку `modules`.

## Скрипты

Для организации кода и реализации SPA в проекте используется фреймворк Backbone. Однако совсем не обязательно знать Backbone от и до для того, чтобы начать писать свой js код. Поскольку много полезных фич, таких как, например, роутинг, уже настроены и работают из коробки.

Backbone - MVP фреймворк ([Model-View-Presenter](https://ru.wikipedia.org/wiki/Model-View-Presenter)), но, как правило, в большинстве проектов не используется Model, а стало быть и Presenter. Работа идет только с [View](http://backbonejs.org/#View), который используется для организации модульности. Отсюда можно воспринимать View просто как модуль.
 
Во View содержится весь js, который иcпользуется на странице. Таким образом, одна страница = одна вьюха. Вьюха привязывается к странице с помощью атрибута `data-view`. Например, если вы создали страницу `news.php`, то для нее необходимо создать вьюху `News.js`, а на самой странице прописать `data-view="News"`.

```php
// Clean HTML
<div class="news" data-view="News"> ... </div>

// Тоже самое на PHP
<? define('PAGE_JS_VIEW','News'); ?>
<div class="news" data-view="<?=PAGE_JS_VIEW?>"> ... </div>
```

### Структура View

```js
app.ns('app.views').News = app.core.Page.extend({

    events: {},                                                       // Обработчики событий
    
    initialize: function() {                                          // Инициализация вьюхи
        app.views.News.__super__.initialize.apply(this, arguments); 
    },
    
    remove: function() {                                              // Удаление вьюхи и обработчиков
        app.views.News.__super__.remove.apply(this, arguments); 
    },
    
    render: function() {                                              // Отрисовка разметки
        app.views.News.__super__.render.apply(this, arguments);
        app.views.News.__super__.afterRender.apply(this, arguments);
    }
    
});
```

### Работа с View

Свой код нужно писать в методе `render()`.
  
Обработчики событий нужно вешать декларативно в объекте `events` (это стандартное [делегирование событий в Backbone](http://backbonejs.org/#View-delegateEvents)). События записываются в следующем формате `{"событие селектор": "обработчик"}`. Например:

```js
events: {
  'click .js-filter-reset': 'e_resetFilters',
  'change .a-checkbox__input': 'e_toggleCheckbox',
  'keyup .js-search-input': '_e_searchInput',
  'focus .js-search-input': function () { ... },
},
```

Профит от такого подхода в том, что при уходе со страницы (при смене вьюхи) обработчики снимаются автоматически.

**Обратите внимание #1!** Backbone требует, чтобы вьюхи были привязаны к конкретному DOM элементу. По-умолчанию таким элементом является `<div class="grid"></div>`. Поэтому если в верстке вы по какой-то причине решили изменить класс корневого элемента для вьюх, не забудьте поменять его также и в `Application.js`!

**Обратите внимание #2!** Если по какой-то причине вы вешаете обработчик jQuery способом, то нужно обязательно его снять в методе `remove()`. Иначе при уходе на другую страницу обработчик так и останется висеть в памяти, что грозит ее утечкой. Чем больше неиспользуемых обработчиков в памяти, тем серьезней утечка и медленнее работает сайт. Это не касается вьюх, чей код используется на всем сайте (`Header.js`, `Footer.js` и т.п.). 

### Работа с subView

Код, который используется на нескольких страницах, нужно класть в папку `subView` и вызывать на тех страницах, где необходимо. Работа с сабвьюхами почти ничем не отличается от работы с вьюхами за исключением того, что для сабвьюх всегда нужно указывать корневой DOM элемент в свойстве `el`.

```js
app.views.MarkNewsAsRead = Backbone.View.extend({

  el: '.article',

  ...
  
});
```

Вызов сабвьюхи выглядит следующим образом:

```js
this.subView['MarkNewsAsRead'] = new app.views.MarkNewsAsRead();
this.subView['MarkNewsAsRead'].render();

// или так
var MarkNewsAsRead = this.subView['MarkNewsAsRead'] = new app.views.MarkNewsAsRead();
MarkNewsAsRead.render();
```

## Настройка резины на rem

Управление резиной осуществляется в файле `Adaptive.js`. В большинстве случаев достаточно лишь правильно указать базовые опции в объекте `cfgs`. Для определения устройства используется библиотека `Device.js`.

### Описание опций

```
<class> : {                                                    // Условия выставления класса <class>
    if: <if>                                                   // условие (функция(<data>,<cfg>)) <data> содержит $el, elWidth, elHeight
    element: < selector || element || $element || domKey >,    // элемент по которому происходят рассчеты размеров
    rem: <px>                                                  // коэфициент перевода rem => px (отменяет зависимость по base)
    from: {                                                    //
        width: <fromWidth> ,                                   // Минимальная ширина элемента
        height: <fromHeight>                                   // Минимальная высота элемента
    },
    to: {
        width: <toWidth> ,                                     // Максимальная ширина элемента
        height: <toHeight>                                     // Максимальная высота элемента
    },
    base: {
        width: <toWidth> ,                                     // Базовая ширина элемента для рассчета коэфициента
        height: <toHeight>                                     // Базовая высота элемента для рассчета коэфициента
    },
    k: <k>,                                                    // Дополнительный коэффициент
    setClass: false || true || <class>,                        // выставлять класс при выполнении условий
    setNoClass: false || true || <class>,                      // выставлять класс при невыполнении условий
    setDeviceType: true || false || <type>,                    // устанавливать новый deviceType при соответствии условиям (key <class> из конфигурации или конкретный <type>)
}
```

### Выставление классов для устройств

Простейшая настройка выглядит следующим образом:

```js
this.cfgs = {
    'desktop': {
        if: device.desktop, // Если устройство определено как desktop
        setClass: true,     // Выставить класс 'desktop'
        setNoClass: true,   // На других устройствах выставить класс 'no-desktop'
        setDeviceType: true // Принудительно установить тип устройства как desktop
    },
    'tablet': { ... },
    'mobile': { ... }
};
```

По-умолчанию все указанные классы добавляются к элементу `<html/>`. Таким образом, настроив выставление классов, можно сразу же пользоваться ими в css.

```css
.article {
  width: 33%;
}

.tablet .article {
  width: 50%;
}
  
.mobile .article {
  width: 100%;
}
```

### Добавление резины

В примере выше мы настроили добавление классов на страницу в зависимости от устройства. Однако там еще не подключена резина. Предположим, ширина контентной части в макете = 1200px. Соответственно на разрешениях меньше 1200px лэйаут начнет ломаться. Чтобы этого не происходило, нужно включать резину на этих разрешениях.

```js
this.cfgs = {
    'desktop': {
        if: device.desktop,
        setClass: true,
        setNoClass: true,
        setDeviceType: true
    },
    'desktop:wide': {
        if: device.desktop,    // Если устройство определено как desktop
        rem: 10,               // Использовать для расчета базовый коэффициент (отключает скейл)
        from: {
            width: 1200        // Применить от 1200px по ширине
        }
    },
    'desktop:thin': {
        if: device.desktop,    // Если устройство определено как desktop
        base: {
            width: 1200        // Использовать для расчета базовую ширину (включает скейл)
        },
        to: {
            width: 1200        // Применить до 1200px по ширине
        }
    },
    'tablet': {...},
    'mobile': {...}
};
```

**Обратите внимание**: опция `rem` отключает скейл страницы, в то время как `base`, наоборот, включает. Приоритет у `rem` выше, чем у `base`, поэтому писать их вместе бессмысленно.

## Спрайты

Сборка спрайтов уже настроена и работает из коробки. Все исходники для спрайтов хранятся в папке `templates\sprites\`. 

### PNG спрайты

Чтобы собрать PNG спрайт для страницы новостей, нужно зайти в `templates\sprites\png\`, создать папку `news` и положить в нее необходимые картинки. Сборщик соберет их в спрайт согласно названию папки - `news.png`, - и положит в `templates\images\png-sprites\`.

Также сборщик соберет `news.less` со всеми необходимыми миксинами и положит их в папку `templates\src\less\core\png-sprites`.

Чтобы быстро подключить в LESS иконку из спрайта, нужно добавить миксин `.bg-png(@png-ИМЯ_КАРТИНКИ)`. Например, вы хотите подключить картинку `favorite.png` (которую предварительно положили в `templates\sprites\png\news\`). Для этого нужно написать `.bg-png(@png-favorite)`.

Итоговый пример:
```less
.selector {
  .bg-png(@png-favorite);
}
```

Остальные варианты подключения смотри в `templates\src\less\core\png-sprites\news.less`.

### SVG спрайты

Чтобы собрать SVG спрайт, нужно зайти в `templates\sprites\svg\` и положить в нее необходимые svg картинки (обратите внимание: никаких дополнительных папок создавать не нужно). Сборщик настроен на сборку SVG спрайтов в двух режимах одновременно: режиме CSS и режиме symbol. На выходе получатся 2 соответствующих спрайта: `sprite.svg` и `symbols.svg`. Сборщик положит их в `templates\images\`.

Эти два режима отличаются от остальных (инлайн в HTML, инлайн в CSS, base64, SVG-stack) почти 100%-й поддержкой во всех современных браузерах (начиная с IE9 включительно), кешируемостью, быстродействием и удобством работы. Подробнее об этом можно почитать, например, [тут](https://habrahabr.ru/post/276463/).

Подключение иконки из `sprite.svg` аналогично подключению png спрайта за рядом исключений:
- спрайт кладется в папку `templates\sprites\svg\`;
- миксины кладутся в `templates\src\less\core\svg-sprite.less`;
- иконка в LESS подключается миксином `.bg-svg(@svg-ИМЯ_КАРТИНКИ)`;
- остальные варианты подключения смотри в `templates\src\less\core\svg-sprite.less`.

Чтобы подключить иконку из `symbols.svg` нужно в разметку добавить следующую конструкцию: 

```html
<svg>
  <use xlink:href="http://<?=$_SERVER['HTTP_HOST'] . WWW_PATH?>templates/images/symbols.svg#ИМЯ_КАРТИНКИ"></use>
</svg>
```

Например, вы хотите подключить картинку `favorite.svg` (которую предварительно положили в `templates\sprites\svg\`). Для этого нужно написать:

```html
<svg>
  <use xlink:href="http://<?=$_SERVER['HTTP_HOST'] . WWW_PATH?>templates/images/symbols.svg#favorite"></use>
</svg>
```

Если по какой-то причине вы не видите изменений в спрайтах, попробуйте удалить их из `templates/images/` и заново запустить сборку.

## Сборка проекта

Задачи из `gulpfile.js` запускаются в терминале в папке `templates` по команде `gulp <имя задачи>`.

### `gulp default` или просто `gulp`

Основная задача сборки на стадии разработки проекта.
- содержит задачи упрощающие процесс разработки
- следит за изменениями в исходных файлах, при необходимости пересобирает проект
- старается не помешать дебагу
- Запускается 1 раз перед началом сессии разработки

### `gulp release`

Основная задача сборки на стадии релиза.
- Максимально сжимает все, что можно
- Старается выпилить все лишнее

Остальные задачи так же могут запускаться вручную, но обычно в этом нет смысла.

При добавлении новых скриптов в проект (в основном это касается библиотек) возможно потребуется добавить их в списки `options.jsInitList / options.jsMainList / options.jsLibsList` в `gulpfile.js` и заново запустить задачу сборки.	

Результат сборки (в основном) складывается в папке `templates/build`.

```
templates                           
    ├── build/                      
        ├── css/
	    ├── styles.css          # во время разработки
	    └── styles.min.css      # в релизной версии подключается в <head>, содержат все стили проекта
        ├── js/
	    ├── init.js             # во время разработки
	    ├── init.min.js         # в релизной версии подключается сразу после <body>  - содержит инициализирующие скрипты, но иногда требует наличия <body> для манипуляции
	    ├── libs.js             # во время разработки
	    ├── libs.min.js         # в релизной версии подключаются перез закрытием <body> - содержат js библиотеки
	    ├── scripts.js          # во время разработки
	    └── scripts.min.js      # в релизной версии подключаются перез закрытием <body> - содержат основные скрипты
```

## Альтернативная сборка с препроцессором Stylus

Чтобы развернуть проект со Stylus, нужно:
- Скачать репозиторий [libs](http://hg.turbodevelopers.com/turbo/libs)
- Перейти в крайнюю ревизию ветки `altVersion-Stylus`
- Создать папку для нового проекта, скопировать туда все содержимое из `libs`
- В терминале перейти в папку `имя_проекта\templates` и запустить `npm install` для установки npm модулей

## Итого

- Чтобы развернуть проект, нужно скачать репозиторий [libs](http://hg.turbodevelopers.com/turbo/libs), перейти в крайнюю ревизию ветки `altVersion-ks` и скопировать содержимое в папку нового проекта.
- Чтобы создать страницу новостей, нужно в `templates\pages` создать файл `news.php`. Страница станет доступна по адресу `имя_проекта/news`.
- Чтобы подключить стили к странице новостей, нужно в `templates\src\less\modules` создать файл `news.less`. Затем подключить этот файл в точке входа `templates\src\less\styles.less`.
- Чтобы подключить скрипты к странице новостей, нужно в `templates\src\js\BView` создать вьюху `News.js`. Затем на странице `news.php` добавить в корневой элемент `data-view="News"`.
- Чтобы подключить резину на ремах, нужно настроить объект `cfgs` в `templates\src\js\components\Adaptive.js`.
- Чтобы собрать PNG спрайт для страницы новостей, нужно в `templates\sprites\png\` создать папку `news` и положить в нее картинки. Чтобы подключить в LESS картинку `favorite.png`, нужно добавить миксин `.bg-png(@png-favorite)`.
- Чтобы собрать SVG спрайт, нужно в `templates\sprites\svg\` положить SVG картинки. Чтобы подключить в LESS картинку `favorite.svg`, нужно добавить миксин `.bg-svg(@svg-favorite)`. Чтобы подключить в HTML картинку `favorite.svg` нужно написать: `<svg><use xlink:href="http://<?=$_SERVER['HTTP_HOST'] . WWW_PATH?>templates/images/symbols.svg#favorite"></use></svg>`
- Перед началом разработки нужно запустить команду `gulp`, а перед релизом `gulp release`.
