# Скрипты

Все скрипты лежат в `templates/src/js/`.

```
js/                     # Скрипты
    ├── BView/          # Backbone Views ("вьюхи" / представления страниц сайта)
        └── subView/    # Модули, которые могут использоваться в нескольких вьюхах
    ├── components/     # Базовые компоненты для работы сайта
    ├── core/           # Базовые классы, от которых расширяются вьюхи
    ├── libs/           # Сторонние библиотеки
    └── script.js       # Точка входа для скриптов (инициализация приложения)
```

Для организации кода и реализации SPA в проекте используется фреймворк Backbone. Однако совсем не обязательно знать Backbone от и до для того, чтобы начать писать свой js код.

Backbone - MVP фреймворк \([Model-View-Presenter](https://ru.wikipedia.org/wiki/Model-View-Presenter)\), но, как правило, в большинстве проектов не используется Model, а стало быть и Presenter. Работа идет только с [View](http://backbonejs.org/#View). 

View используется для организации модульности кода. Отсюда можно воспринимать View просто как модуль. Во View содержится весь js, который иcпользуется на странице. Таким образом, одна страница = одна вьюха.

Вьюха привязывается к странице (а точнее к URL) с помощью атрибута `data-view`. Раньше мы пытались использовать [статическую таблицу роутинга](http://backbonejs.org/#Router-routes), но потом от нее отказались. Дело в том, что в большинстве проектов используется наша админка, в которой можно управлять деревом разделов (добавлять, удалять и менять URL). А поддерживать таблицу роутинга в актуальном состоянии после каждого изменения в админке довольно сложно. Генерировать её из админки тоже довольно сложно. Поэтому мы упростили роутинг, и на каждой странице выводим `data-view="<ИМЯ_ВЬЮХИ>"`, который определяет текущую вьюшку.

Вьюхи нужно класть в `templates/src/js/BView/`. Из коробки уже присутствуют такие вьюхи:

```
Footer.js - вьюха футера
Header.js - вьюха хедера
Index.js - вьюха главной страницы
NotFound.js - вьюха страницы 404
Page1.js - демонстрационная вьюха
```

Таким образом, если вы создали страницу `news.php`, то для нее необходимо создать вьюху `News.js`, а в `news.php` указать `data-view="News"`.

```php
<? define('PAGE_JS_VIEW','News'); ?>
<div class="news" data-view="<?=PAGE_JS_VIEW?>"> ... </div>
```

То же самое, если вы верстаете на Jade (см. [Верстка на Jade](jade.md)):

```jade
+module(MODULE.DEFINE_VIEW, {view: 'News'})
block content
    .news(data-view!='<?=PAGE_JS_VIEW?>')
```

## Структура View

Рассмотрим структуру View на примере `News.js`.

```js
app.ns('app.views').News = app.core.Page.extend({

    // Обработчики событий
    events: {},
    
    // Инициализация вьюхи (когда пришли на страницу)
    initialize: function() {
        app.views.News.__super__.initialize.apply(this, arguments); 
    },

    // Удаление вьюхи и обработчиков (когда ушли со страницы)
    remove: function() {
        app.views.News.__super__.remove.apply(this, arguments); 
    },

    // Отрисовка в DOM
    render: function() {
        app.views.News.__super__.render.apply(this, arguments);
        app.views.News.__super__.afterRender.apply(this, arguments);
    }

});
```

## Работа с View

Свой код нужно писать в методе `render()`.

Обработчики событий нужно вешать декларативно в объекте `events` \(это стандартное [делегирование событий в Backbone](http://backbonejs.org/#View-delegateEvents)\). События записываются в следующем формате `{"событие селектор": "обработчик"}`. Например:

```js
events: {
  'click .js-filter-reset': 'e_resetFilters',
  'change .a-checkbox__input': 'e_toggleCheckbox',
  'keyup .js-search-input': '_e_searchInput',
  'focus .js-search-input': function () { ... },
},
```

Профит от такого подхода в том, что при уходе со страницы \(при смене вьюхи\) обработчики снимаются автоматически.

**Обратите внимание \#1!** Backbone требует, чтобы вьюхи были привязаны к конкретному DOM элементу. По умолчанию таким элементом является `<div class="grid"></div>`. Поэтому если в верстке вы, по какой-то причине, решили изменить класс корневого элемента для вьюх, не забудьте поменять его также и в `templates/src/js/components/Application.js`!

**Обратите внимание \#2!** Если, по какой-то причине, вы вешаете обработчик jQuery способом, то нужно обязательно его снять в методе `remove()`. Иначе при уходе на другую страницу обработчик так и останется висеть в памяти, что грозит ее [утечкой](http://learn.javascript.ru/memory-leaks-jquery). Чем больше неиспользуемых обработчиков в памяти, тем серьезней утечка и медленнее работает сайт. Это не касается вьюх, чей код используется на всем сайте \(`Header.js`, `Footer.js` и т.п.\).

## Работа с subView

Код, который используется на нескольких страницах, нужно класть в `templates/src/js/BView/subView` и вызывать на тех страницах (вьюхах), где необходимо. Это не относится к хедеру и футеру, т.к. традиционно они уже подключены и находятся в `templates/src/js/BView/`. Работа с сабвьюхами почти ничем не отличается от работы с вьюхами за исключением того, что для сабвьюх всегда нужно указывать корневой DOM элемент в свойстве `el`.

```js
app.views.MarkNewsAsRead = Backbone.View.extend({

  el: '.article',

  ...

});
```

Вызвать сабвьюху можно в методе `render()` любой вьюхи следующим образом:

```js
this.subView['MarkNewsAsRead'] = new app.views.MarkNewsAsRead();
this.subView['MarkNewsAsRead'].render();

// или так
var MarkNewsAsRead = this.subView['MarkNewsAsRead'] = new app.views.MarkNewsAsRead();
MarkNewsAsRead.render();
```



